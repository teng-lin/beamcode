# Architecture Gaps G1/G2/G3 Implementation Plan (v2)

> **For Claude:** REQUIRED SUB-SKILL: Use superpowers:executing-plans to implement this plan task-by-task.

**Goal:** Close the three highest-leverage architecture gaps — structured error handling (G1), state persistence safety (G2), and observability (G3) — to make failures visible and prevent silent data loss.

**Architecture:** Add a minimal error type hierarchy (3 classes, not 7), replace `NoopLogger` defaults with a structured JSON logger using existing `ctx` parameter for correlation IDs, and introduce schema versioning with a step-registry migrator. All changes are additive — existing interfaces are extended, not replaced.

**Tech Stack:** TypeScript, vitest, no new dependencies

---

## Changes from v1 (review findings incorporated)

| Finding | Source | Resolution |
|---------|--------|------------|
| Error hierarchy over-specified (YAGNI) | Simplicity, Oracle | Reduced from 7 classes to 3: `BeamCodeError` + `StorageError` + `ProcessError` |
| `child()` not on Logger interface — Task 4 won't compile | All 4 reviewers | Dropped `child()` entirely. Use existing `ctx` parameter for correlation IDs |
| String vs. Error coercion mismatch | Momus, Oracle | Added `errorMessage()` helper alongside `toBeamCodeError()` — two patterns, two utilities |
| Migrator won't scale past v2 | Architect | Restructured as step-registry with `Map<number, MigrationFn>` |
| `JSON.stringify` circular ref bomb in logger | Momus | Added try-catch with safe fallback in `emit()` |
| `LogLevel.SILENT` redundant with NoopLogger | Simplicity | Removed |
| Stale line numbers in session-bridge | Oracle | Narrowed Task 2 to `process-supervisor.ts` only (verified callsites) |
| Task 7 is ceremony | Simplicity | Merged exports into parent tasks |
| Missing state validation beyond `id` check | Oracle, Architect | Added `typeof session.state === "object"` validation |
| `Date.now()` not OTel-friendly | Architect | Changed to ISO 8601 timestamps |
| Ambiguous "throw/log" for file-storage | Architect, Momus | Clarified: log only, do not rethrow |

---

## Current State (from research)

### What's already good
- `FileStorage` already implements atomic writes (write-to-temp + fsync + rename)
- `Logger` interface already accepts `ctx?: Record<string, unknown>` — structured data and correlation IDs work through existing API
- `MetricsCollector` interface is well-designed with typed events
- `SlidingWindowBreaker` circuit breaker exists for process restart failures

### What's missing
- **G1**: Zero custom error classes. 43+ catch blocks, many swallowing silently. `err instanceof Error ? err : new Error(String(err))` coercion repeated 7+ times, but two distinct patterns exist: some extract `.message` (string), others produce an `Error` object
- **G2**: No `schemaVersion` field in `PersistedSession`. No migration support. No state object validation
- **G3**: `NoopLogger` is default in `SessionManager`/`ProcessSupervisor`. `ConsoleLogger` outputs unstructured text. No correlation IDs. No log level filtering

---

## Task 1: Error Types + Utilities

**Files:**
- Create: `src/errors.ts`
- Test: `src/errors.test.ts`
- Modify: `src/index.ts` (add exports)

### Step 1: Write the failing test

```typescript
// src/errors.test.ts
import { describe, expect, it } from "vitest";
import {
  BeamCodeError,
  StorageError,
  ProcessError,
  toBeamCodeError,
  errorMessage,
} from "./errors.js";

describe("BeamCodeError hierarchy", () => {
  it("BeamCodeError is an Error with code", () => {
    const err = new BeamCodeError("test", "TEST_ERROR");
    expect(err).toBeInstanceOf(Error);
    expect(err.name).toBe("BeamCodeError");
    expect(err.code).toBe("TEST_ERROR");
    expect(err.message).toBe("test");
  });

  it("domain errors have correct codes and extend BeamCodeError", () => {
    const storage = new StorageError("write failed");
    expect(storage).toBeInstanceOf(BeamCodeError);
    expect(storage).toBeInstanceOf(Error);
    expect(storage.code).toBe("STORAGE");
    expect(storage.name).toBe("StorageError");

    const process = new ProcessError("spawn failed");
    expect(process).toBeInstanceOf(BeamCodeError);
    expect(process.code).toBe("PROCESS");
    expect(process.name).toBe("ProcessError");
  });

  it("preserves cause chain", () => {
    const cause = new Error("original");
    const err = new StorageError("write failed", { cause });
    expect(err.cause).toBe(cause);
  });
});

describe("toBeamCodeError", () => {
  it("passes through BeamCodeError unchanged", () => {
    const err = new BeamCodeError("x", "X");
    expect(toBeamCodeError(err)).toBe(err);
  });

  it("wraps plain Error with cause chain", () => {
    const plain = new Error("plain");
    const wrapped = toBeamCodeError(plain);
    expect(wrapped).toBeInstanceOf(BeamCodeError);
    expect(wrapped.message).toBe("plain");
    expect(wrapped.cause).toBe(plain);
  });

  it("wraps non-Error values", () => {
    expect(toBeamCodeError("string error").message).toBe("string error");
    expect(toBeamCodeError(42).message).toBe("42");
    expect(toBeamCodeError(null).message).toBe("Unknown error");
    expect(toBeamCodeError(undefined).message).toBe("Unknown error");
  });
});

describe("errorMessage", () => {
  it("extracts message from Error instances", () => {
    expect(errorMessage(new Error("boom"))).toBe("boom");
    expect(errorMessage(new BeamCodeError("typed", "T"))).toBe("typed");
  });

  it("stringifies non-Error values", () => {
    expect(errorMessage("string error")).toBe("string error");
    expect(errorMessage(42)).toBe("42");
    expect(errorMessage(null)).toBe("Unknown error");
    expect(errorMessage(undefined)).toBe("Unknown error");
  });
});
```

### Step 2: Run test to verify it fails

Run: `npx vitest run src/errors.test.ts`
Expected: FAIL — module `./errors.js` not found

### Step 3: Write minimal implementation

```typescript
// src/errors.ts

export class BeamCodeError extends Error {
  readonly code: string;

  constructor(message: string, code: string, options?: ErrorOptions) {
    super(message, options);
    this.name = "BeamCodeError";
    this.code = code;
  }
}

// ── Domain errors ──

export class StorageError extends BeamCodeError {
  constructor(message: string, options?: ErrorOptions) {
    super(message, "STORAGE", options);
    this.name = "StorageError";
  }
}

export class ProcessError extends BeamCodeError {
  constructor(message: string, options?: ErrorOptions) {
    super(message, "PROCESS", options);
    this.name = "ProcessError";
  }
}

// ── Utilities ──

/** Coerce unknown thrown value to BeamCodeError (preserves cause chain). */
export function toBeamCodeError(value: unknown): BeamCodeError {
  if (value instanceof BeamCodeError) return value;
  if (value instanceof Error) return new BeamCodeError(value.message, "UNKNOWN", { cause: value });
  return new BeamCodeError(String(value ?? "Unknown error"), "UNKNOWN");
}

/** Extract error message string from unknown thrown value. */
export function errorMessage(value: unknown): string {
  if (value instanceof Error) return value.message;
  if (value == null) return "Unknown error";
  return String(value);
}
```

### Step 4: Run test to verify it passes

Run: `npx vitest run src/errors.test.ts`
Expected: PASS

### Step 5: Add exports to index.ts

Add to `src/index.ts`:
```typescript
// Errors
export {
  BeamCodeError,
  StorageError,
  ProcessError,
  toBeamCodeError,
  errorMessage,
} from "./errors.js";
```

### Step 6: Run build

Run: `npx tsdown`
Expected: Build succeeds

### Step 7: Commit

```bash
git add src/errors.ts src/errors.test.ts src/index.ts
git commit -m "feat(g1): add structured error types with toBeamCodeError and errorMessage utilities"
```

---

## Task 2: Adopt Error Types in Process Supervisor

**Files:**
- Modify: `src/core/process-supervisor.ts` (replace local `toError()` with `toBeamCodeError()`)
- Test: existing tests must still pass

**Why only process-supervisor:** This is the only file with a duplicate local `toError()` utility (lines 45-48). The `session-bridge.ts` coercion sites use two distinct patterns (string extraction vs. Error wrapping) — those are better addressed incrementally as callers gain typed error consumers. The `file-storage.ts` sites deliberately catch-and-continue; changing them to throw would alter behavior.

### Step 1: Replace `toError()` in process-supervisor

1. Delete the local `toError()` function at lines 45-48
2. Add import: `import { toBeamCodeError } from "../errors.js";`
3. Replace `toError(err)` at line 122 with `toBeamCodeError(err)`
4. Replace `toError(spawnErr)` at line 134 with `toBeamCodeError(spawnErr)`

### Step 2: Run all tests

Run: `npx vitest run`
Expected: All 1543+ tests pass. `BeamCodeError extends Error` so the `SupervisorEventMap.error` type (`{ error: Error }`) still accepts it.

### Step 3: Commit

```bash
git add src/core/process-supervisor.ts
git commit -m "refactor(g1): replace local toError with toBeamCodeError in process-supervisor"
```

---

## Task 3: Structured Logger

**Files:**
- Create: `src/adapters/structured-logger.ts`
- Test: `src/adapters/structured-logger.test.ts`
- Modify: `src/index.ts` (add exports)

**Design decisions (from review):**
- No `child()` method — use existing `ctx` parameter for correlation IDs
- No `LogLevel.SILENT` — that's what `NoopLogger` is for
- ISO 8601 timestamps for log aggregation compatibility
- Try-catch around `JSON.stringify` to handle circular refs safely

### Step 1: Write the failing test

```typescript
// src/adapters/structured-logger.test.ts
import { describe, expect, it } from "vitest";
import { StructuredLogger, LogLevel } from "./structured-logger.js";

describe("StructuredLogger", () => {
  it("outputs JSON lines to the writer", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({ writer: (line) => lines.push(line) });

    logger.info("server started", { port: 3456 });

    const parsed = JSON.parse(lines[0]);
    expect(parsed.level).toBe("info");
    expect(parsed.msg).toBe("server started");
    expect(parsed.port).toBe(3456);
    expect(parsed.time).toBeTypeOf("string"); // ISO 8601
  });

  it("respects log level filtering", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({
      writer: (line) => lines.push(line),
      level: LogLevel.WARN,
    });

    logger.debug("hidden");
    logger.info("hidden");
    logger.warn("visible");
    logger.error("visible");

    expect(lines).toHaveLength(2);
  });

  it("includes component name when set", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({
      writer: (line) => lines.push(line),
      component: "session-bridge",
    });

    logger.info("test");

    const parsed = JSON.parse(lines[0]);
    expect(parsed.component).toBe("session-bridge");
  });

  it("passes correlation ID through ctx parameter", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({ writer: (line) => lines.push(line) });

    logger.info("message received", { correlationId: "sess-abc-123" });

    const parsed = JSON.parse(lines[0]);
    expect(parsed.correlationId).toBe("sess-abc-123");
  });

  it("serializes error objects with stack", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({ writer: (line) => lines.push(line) });

    logger.error("failed", { error: new Error("boom") });

    const parsed = JSON.parse(lines[0]);
    expect(parsed.error).toBe("boom");
    expect(parsed.errorStack).toContain("Error: boom");
  });

  it("survives circular references in ctx", () => {
    const lines: string[] = [];
    const logger = new StructuredLogger({ writer: (line) => lines.push(line) });

    const circular: Record<string, unknown> = { key: "value" };
    circular.self = circular;

    // Should not throw
    logger.error("circular data", circular);

    expect(lines).toHaveLength(1);
    const parsed = JSON.parse(lines[0]);
    expect(parsed.msg).toBe("circular data");
  });
});
```

### Step 2: Run test to verify it fails

Run: `npx vitest run src/adapters/structured-logger.test.ts`
Expected: FAIL — module not found

### Step 3: Write minimal implementation

```typescript
// src/adapters/structured-logger.ts
import type { Logger } from "../interfaces/logger.js";

export enum LogLevel {
  DEBUG = 0,
  INFO = 1,
  WARN = 2,
  ERROR = 3,
}

const LEVEL_NAMES: Record<LogLevel, string> = {
  [LogLevel.DEBUG]: "debug",
  [LogLevel.INFO]: "info",
  [LogLevel.WARN]: "warn",
  [LogLevel.ERROR]: "error",
};

export interface StructuredLoggerOptions {
  writer?: (line: string) => void;
  level?: LogLevel;
  component?: string;
}

export class StructuredLogger implements Logger {
  private writer: (line: string) => void;
  private level: LogLevel;
  private component: string | undefined;

  constructor(options: StructuredLoggerOptions = {}) {
    this.writer = options.writer ?? ((line) => process.stderr.write(`${line}\n`));
    this.level = options.level ?? LogLevel.DEBUG;
    this.component = options.component;
  }

  debug(msg: string, ctx?: Record<string, unknown>): void {
    this.emit(LogLevel.DEBUG, msg, ctx);
  }

  info(msg: string, ctx?: Record<string, unknown>): void {
    this.emit(LogLevel.INFO, msg, ctx);
  }

  warn(msg: string, ctx?: Record<string, unknown>): void {
    this.emit(LogLevel.WARN, msg, ctx);
  }

  error(msg: string, ctx?: Record<string, unknown>): void {
    this.emit(LogLevel.ERROR, msg, ctx);
  }

  private emit(level: LogLevel, msg: string, ctx?: Record<string, unknown>): void {
    if (level < this.level) return;

    const entry: Record<string, unknown> = {
      time: new Date().toISOString(),
      level: LEVEL_NAMES[level],
      msg,
    };

    if (this.component) entry.component = this.component;

    if (ctx) {
      for (const [key, value] of Object.entries(ctx)) {
        if (value instanceof Error) {
          entry[key] = value.message;
          entry[`${key}Stack`] = value.stack;
        } else {
          entry[key] = value;
        }
      }
    }

    try {
      this.writer(JSON.stringify(entry));
    } catch {
      // Circular reference or serialization failure — emit safe fallback
      this.writer(JSON.stringify({ time: entry.time, level: entry.level, msg, serializationError: true }));
    }
  }
}
```

### Step 4: Run test to verify it passes

Run: `npx vitest run src/adapters/structured-logger.test.ts`
Expected: PASS

### Step 5: Add exports to index.ts

Add to `src/index.ts`:
```typescript
// Structured logging
export { StructuredLogger, LogLevel } from "./adapters/structured-logger.js";
export type { StructuredLoggerOptions } from "./adapters/structured-logger.js";
```

### Step 6: Commit

```bash
git add src/adapters/structured-logger.ts src/adapters/structured-logger.test.ts src/index.ts
git commit -m "feat(g3): add structured JSON logger with level filtering and safe serialization"
```

---

## Task 4: Wire Structured Logger as Default

**Files:**
- Modify: `src/bin/beamcode.ts` (use `StructuredLogger` instead of `ConsoleLogger`)
- Test: existing tests must still pass

**Design decision:** Correlation IDs are passed via the existing `ctx` parameter (e.g., `this.logger.info("msg", { correlationId: sessionId })`). No Logger interface changes needed. No `child()` method. `SessionBridge` already uses `this.logger` with `ctx` — adding `{ correlationId }` to relevant log calls is a targeted change, not a refactor.

### Step 1: Update beamcode.ts entry point

1. Replace `import { ConsoleLogger }` with `import { StructuredLogger, LogLevel }` from `../adapters/structured-logger.js`
2. Replace line 110 `const logger = new ConsoleLogger()` with:
   ```typescript
   const logger = new StructuredLogger({
     component: "beamcode",
     level: config.verbose ? LogLevel.DEBUG : LogLevel.INFO,
   });
   ```
3. Keep `ConsoleLogger` import for the startup banner (the banner uses `console.log` directly, which is fine for human-readable CLI output)

Note: `config.verbose` already exists in `CliConfig` (line 26: `verbose: boolean`) and is parsed from `--verbose`/`-v` flags (lines 88-90).

### Step 2: Run all tests

Run: `npx vitest run`
Expected: All tests pass. Tests use `noopLogger` or their own mocks — the default logger in `beamcode.ts` is not exercised by tests.

### Step 3: Commit

```bash
git add src/bin/beamcode.ts
git commit -m "feat(g3): wire structured logger as default in beamcode entry point"
```

---

## Task 5: State Schema Versioning + Wire into FileStorage

**Files:**
- Modify: `src/types/session-state.ts` (add `schemaVersion` field to `PersistedSession`)
- Create: `src/adapters/state-migrator.ts`
- Test: `src/adapters/state-migrator.test.ts`
- Modify: `src/adapters/file-storage.ts` (validate and migrate on load, stamp on save)
- Modify: `src/adapters/file-storage.test.ts` (add migration tests)
- Modify: `src/index.ts` (add exports)

**Design decision (from Architect review):** Use a step-registry pattern (`Map<number, MigrationFn>`) with a `while (version < CURRENT)` loop. Costs nothing extra for v0-to-v1 but makes v2+ migrations a one-line map addition. Validate `session.state` is an object, not just `session.id` is a string.

### Step 1: Write the failing migrator test

```typescript
// src/adapters/state-migrator.test.ts
import { describe, expect, it } from "vitest";
import { migrateSession, CURRENT_SCHEMA_VERSION } from "./state-migrator.js";

describe("state-migrator", () => {
  it("returns null for null input", () => {
    expect(migrateSession(null)).toBeNull();
  });

  it("returns null for non-object input", () => {
    expect(migrateSession("string")).toBeNull();
    expect(migrateSession(42)).toBeNull();
  });

  it("returns null when id is not a string", () => {
    expect(migrateSession({ state: {} })).toBeNull();
    expect(migrateSession({ id: 123, state: {} })).toBeNull();
  });

  it("returns null when state is not an object", () => {
    expect(migrateSession({ id: "test", state: "corrupt" })).toBeNull();
    expect(migrateSession({ id: "test" })).toBeNull();
  });

  it("adds schemaVersion to v0 (unversioned) sessions", () => {
    const v0 = { id: "test-id", state: { session_id: "test-id" }, messageHistory: [] };
    const result = migrateSession(v0);
    expect(result).not.toBeNull();
    expect(result!.schemaVersion).toBe(CURRENT_SCHEMA_VERSION);
  });

  it("passes through current-version sessions unchanged", () => {
    const current = {
      id: "test-id",
      state: { session_id: "test-id" },
      messageHistory: [],
      pendingMessages: [],
      pendingPermissions: [],
      schemaVersion: CURRENT_SCHEMA_VERSION,
    };
    const result = migrateSession(current);
    expect(result).toEqual(current);
  });

  it("returns null for future versions it cannot handle", () => {
    const future = {
      id: "test-id",
      state: { session_id: "test-id" },
      messageHistory: [],
      schemaVersion: 999,
    };
    expect(migrateSession(future)).toBeNull();
  });

  it("adds default fields missing in v0 sessions", () => {
    const v0 = { id: "test-id", state: { session_id: "test-id" } };
    const result = migrateSession(v0);
    expect(result!.messageHistory).toEqual([]);
    expect(result!.pendingMessages).toEqual([]);
    expect(result!.pendingPermissions).toEqual([]);
  });
});
```

### Step 2: Run test to verify it fails

Run: `npx vitest run src/adapters/state-migrator.test.ts`
Expected: FAIL — module not found

### Step 3: Add schemaVersion to PersistedSession

In `src/types/session-state.ts`, add `schemaVersion?: number` to `PersistedSession`. Optional for backward compat (unversioned files are treated as v0).

### Step 4: Write migrator implementation (step-registry pattern)

```typescript
// src/adapters/state-migrator.ts
import type { PersistedSession } from "../types/session-state.js";

export const CURRENT_SCHEMA_VERSION = 1;

type MigrationFn = (session: Record<string, unknown>) => Record<string, unknown>;

/** Map from source version to the function that migrates to source+1. */
const migrations: Map<number, MigrationFn> = new Map([
  [0, migrateV0ToV1],
]);

function migrateV0ToV1(session: Record<string, unknown>): Record<string, unknown> {
  return {
    ...session,
    messageHistory: Array.isArray(session.messageHistory) ? session.messageHistory : [],
    pendingMessages: Array.isArray(session.pendingMessages) ? session.pendingMessages : [],
    pendingPermissions: Array.isArray(session.pendingPermissions)
      ? session.pendingPermissions
      : [],
    schemaVersion: 1,
  };
}

/**
 * Migrate a persisted session to the current schema version.
 * Returns null if the session cannot be migrated (corrupt, missing fields, or future version).
 */
export function migrateSession(raw: unknown): PersistedSession | null {
  if (raw == null || typeof raw !== "object") return null;

  const session = raw as Record<string, unknown>;

  // Required fields
  if (typeof session.id !== "string") return null;
  if (session.state == null || typeof session.state !== "object") return null;

  let version = typeof session.schemaVersion === "number" ? session.schemaVersion : 0;

  // Cannot downgrade from future versions
  if (version > CURRENT_SCHEMA_VERSION) return null;

  // Already current
  if (version === CURRENT_SCHEMA_VERSION) return raw as PersistedSession;

  // Run migration chain
  let current = session;
  while (version < CURRENT_SCHEMA_VERSION) {
    const migrate = migrations.get(version);
    if (!migrate) return null; // Gap in migration chain
    current = migrate(current);
    version++;
  }

  return current as PersistedSession;
}
```

### Step 5: Run migrator test to verify it passes

Run: `npx vitest run src/adapters/state-migrator.test.ts`
Expected: PASS

### Step 6: Write failing FileStorage integration test

Add to `src/adapters/file-storage.test.ts` in the existing describe block:

```typescript
it("migrates unversioned sessions on load", () => {
  // Write a v0 session directly (no schemaVersion field)
  const v0 = JSON.stringify({
    id: VALID_UUID,
    state: { session_id: VALID_UUID, model: "test", cwd: "/test", tools: [],
             permissionMode: "default", claude_code_version: "1.0",
             mcp_servers: [], agents: [], slash_commands: [], skills: [],
             total_cost_usd: 0, num_turns: 0, context_used_percent: 0,
             is_compacting: false, git_branch: "", is_worktree: false,
             repo_root: "", git_ahead: 0, git_behind: 0,
             total_lines_added: 0, total_lines_removed: 0 },
    messageHistory: [],
  });
  writeFileSync(join(storageDir, `${VALID_UUID}.json`), v0);

  const loaded = storage.load(VALID_UUID);
  expect(loaded).not.toBeNull();
  expect(loaded!.schemaVersion).toBe(1);
  expect(loaded!.pendingMessages).toEqual([]);
  expect(loaded!.pendingPermissions).toEqual([]);
});

it("returns null for corrupt session files instead of crashing", () => {
  writeFileSync(join(storageDir, `${VALID_UUID}.json`), "not json{{{");
  expect(storage.load(VALID_UUID)).toBeNull();
});
```

Note: Use `VALID_UUID` and `storageDir` from the existing test harness. The existing `beforeEach` creates `storageDir` via `mkdtempSync` and constructs `storage = new FileStorage(storageDir)`.

### Step 7: Update FileStorage to use migrator

In `src/adapters/file-storage.ts`:

1. Add import: `import { migrateSession, CURRENT_SCHEMA_VERSION } from "./state-migrator.js";`
2. In `load()`, after `JSON.parse(raw)`, pass through `migrateSession()`:
   ```typescript
   load(sessionId: string): PersistedSession | null {
     try {
       const raw = readFileSync(this.filePath(sessionId), "utf-8");
       return migrateSession(JSON.parse(raw));
     } catch {
       return null;
     }
   }
   ```
3. In `loadAll()`, pass each parsed session through `migrateSession()`, skip nulls
4. In `saveSync()`, stamp `session.schemaVersion = CURRENT_SCHEMA_VERSION` before `atomicWrite()`

**Important:** Do NOT change the `console.error` calls in `saveSync()` (line 135) and `saveLauncherState()` (line 197) to throw. They deliberately catch-and-continue to preserve fault tolerance. The `console.error` calls are acceptable here — `FileStorage` does not have a logger dependency and adding one is out of scope for this task.

### Step 8: Run all tests

Run: `npx vitest run`
Expected: All tests pass

### Step 9: Add exports to index.ts

Add to `src/index.ts`:
```typescript
// State migration
export { migrateSession, CURRENT_SCHEMA_VERSION } from "./adapters/state-migrator.js";
```

### Step 10: Commit

```bash
git add src/types/session-state.ts src/adapters/state-migrator.ts src/adapters/state-migrator.test.ts src/adapters/file-storage.ts src/adapters/file-storage.test.ts src/index.ts
git commit -m "feat(g2): add state schema versioning with step-registry migrator"
```

---

## Summary

| Task | Gap | What | Key Files |
|------|-----|------|-----------|
| 1 | G1 | Error types + utilities | `src/errors.ts` |
| 2 | G1 | Adopt in process-supervisor | `src/core/process-supervisor.ts` |
| 3 | G3 | Structured JSON logger | `src/adapters/structured-logger.ts` |
| 4 | G3 | Wire logger in entry point | `src/bin/beamcode.ts` |
| 5 | G2 | State schema versioning + FileStorage wiring | `src/adapters/state-migrator.ts`, `src/adapters/file-storage.ts` |

### What's NOT in scope (intentionally)
- **Remaining coercion sites in session-bridge.ts** — two distinct patterns (string extraction vs. Error wrapping) with no typed error consumers yet. Better addressed incrementally.
- **Logger injection into FileStorage** — would require constructor change; `console.error` is acceptable for 2 callsites
- **Config validation with zod** (G6) — adds a dependency; separate follow-up
- **Retry logic** — no retry exists yet; add `TransientError` when retry is implemented
- **Metrics wiring** — MetricsCollector interface is already good; wiring is a separate task
- **Frontend changes** — these are all backend/core changes
- **Additional domain errors** (SessionNotFoundError, AuthenticationError, ConfigurationError) — no typed consumers exist yet; add alongside the consumers

### YAGNI classes removed from v1
| Removed | Reason |
|---------|--------|
| `TransientError` | Zero retry logic in codebase |
| `FatalError` | No code distinguishes fatal vs. non-fatal |
| `SessionNotFoundError` | HTTP handlers already return 404 inline |
| `AuthenticationError` | Zero authentication error patterns |
| `ConfigurationError` | 1 callsite in entire codebase |
| `isTransient()` | Zero consumers |
